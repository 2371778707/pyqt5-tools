--- pluginloader.cpp	2017-07-06 10:17:19.373575300 -0700
+++ pluginloader.cpp	2017-07-06 11:06:16.320507700 -0700
@@ -25,6 +25,7 @@
 
 #include <stdlib.h>
 
+#include <QDebug>
 #include <QtGlobal>
 #include <QtPlugin>
 #include <QCoreApplication>
@@ -37,6 +38,181 @@
 #include "../qpy/QtDesigner/qpydesignercustomwidgetplugin.h"
 
 
+const char * moduleName = "exceptiondialog";
+const char * moduleCode = "\
+import functools\
+import sys\
+import traceback\
+\
+from PyQt5 import QtCore, QtWidgets\
+\
+QtCore.qDebug('Importing module for exception dialogs')\
+\
+def exception_message_box(excType=None, excValue=None, tracebackobj=None):\
+    message = traceback.format_exception(excType, excValue, tracebackobj)\
+    message = ''.join(message)\
+\
+    dialog(\
+        parent=None,\
+        title='Exception',\
+        message=message,\
+        icon=QtWidgets.QMessageBox.Critical,\
+    )\
+\
+class FittedTextBrowser(QtWidgets.QTextBrowser):\
+    def sizeHint(self):\
+        default = super().sizeHint()\
+\
+        if not default.isValid():\
+            return default\
+\
+        document_size = self.document().size()\
+\
+        desktops = QtWidgets.QApplication.desktop()\
+        screen_number = desktops.screenNumber(self.parent())\
+        geometry = desktops.screenGeometry(screen_number)\
+\
+        if document_size.width() == 0:\
+            document_size.setWidth(geometry.width() * 0.25)\
+        if document_size.height() == 0:\
+            document_size.setHeight(geometry.height() * 0.4)\
+\
+        scrollbar_width = QtWidgets.QApplication.style().pixelMetric(\
+            QtWidgets.QStyle.PM_ScrollBarExtent\
+        )\
+\
+        width = sum((\
+            document_size.width(),\
+            self.contentsMargins().left(),\
+            self.contentsMargins().right(),\
+            scrollbar_width,\
+        ))\
+\
+        height = sum((\
+            document_size.height(),\
+            self.contentsMargins().top(),\
+            self.contentsMargins().bottom(),\
+            scrollbar_width,\
+        ))\
+\
+        return QtCore.QSize(width, height)\
+\
+\
+class DialogUi:\
+    def __init__(self, parent):\
+        self.layout = QtWidgets.QGridLayout(parent)\
+        self.icon = QtWidgets.QLabel(parent)\
+        self.message = FittedTextBrowser(parent)\
+        self.copy = QtWidgets.QPushButton(parent)\
+        self.buttons = QtWidgets.QDialogButtonBox(parent)\
+\
+        self.copy.setText('Copy To Clipboard')\
+\
+        self.layout.addWidget(self.icon, 0, 0)\
+        self.layout.addWidget(self.message, 0, 1, 1, 2)\
+        self.layout.addWidget(self.copy, 1, 1)\
+        self.layout.addWidget(self.buttons, 1, 2)\
+\
+        self.layout.setAlignment(self.copy, QtCore.Qt.AlignLeft)\
+\
+        self.layout.setRowStretch(0, 1)\
+        self.layout.setColumnStretch(1, 1)\
+\
+\
+class Dialog(QtWidgets.QDialog):\
+    def __init__(self, *args, cancellable=False, **kwargs):\
+        super().__init__(*args, **kwargs)\
+\
+        self.ui = DialogUi(parent=self)\
+\
+        self.ui.buttons.accepted.connect(self.accept)\
+        self.ui.buttons.rejected.connect(self.reject)\
+\
+        self.ui.copy.clicked.connect(self.copy)\
+\
+        self.setLayout(self.ui.layout)\
+        buttons = QtWidgets.QDialogButtonBox.Ok\
+        if cancellable:\
+            buttons |= QtWidgets.QDialogButtonBox.Cancel\
+\
+        self.ui.buttons.setStandardButtons(buttons)\
+\
+        self.text = None\
+        self.html = None\
+\
+        self.cached_maximum_size = self.maximumSize()\
+\
+        desktops = QtWidgets.QApplication.desktop()\
+        screen_number = desktops.screenNumber(self.parent())\
+        geometry = desktops.screenGeometry(screen_number)\
+\
+        self.setMaximumHeight(geometry.height() * 0.7)\
+        self.setMaximumWidth(geometry.width() * 0.7)\
+\
+    def copy(self):\
+        QtWidgets.QApplication.clipboard().setText(\
+            self.ui.message.toPlainText() + '\\n'\
+        )\
+\
+    def set_text(self, text):\
+        self.ui.message.setPlainText(text)\
+\
+        self.html = None\
+        self.text = text\
+\
+        self.ui.message.setLineWrapMode(QtWidgets.QTextEdit.NoWrap)\
+\
+    def set_html(self, html):\
+        self.ui.message.setHtml(html)\
+\
+        self.html = html\
+        self.text = None\
+\
+        self.ui.message.setLineWrapMode(QtWidgets.QTextEdit.WidgetWidth)\
+\
+    def set_message_box_icon(self, icon):\
+        self.ui.icon.setPixmap(QtWidgets.QMessageBox.standardIcon(icon))\
+\
+    def exec(self):\
+        QtCore.QTimer.singleShot(10, functools.partial(\
+                self.setMaximumSize,\
+                self.cached_maximum_size,\
+        ))\
+\
+        return super().exec()\
+\
+\
+def dialog(parent, message, title=None, icon=None,\
+           rich_text=False, cancellable=False):\
+    box = Dialog(parent=parent, cancellable=cancellable)\
+\
+    if rich_text:\
+        box.set_html(message)\
+    else:\
+        box.set_text(message)\
+\
+    if icon is not None:\
+        box.set_message_box_icon(icon)\
+\
+    if title is not None:\
+        parent_title = QtWidgets.QApplication.instance().applicationName()\
+\
+        if len(parent_title) > 0:\
+            title = ' - '.join((\
+                parent_title,\
+                title,\
+            ))\
+\
+\
+        box.setWindowTitle(title)\
+\
+    return box.exec()\
+\
+QtCore.qDebug('Setting sys.excepthook to provide dialog')\
+sys.excepthook = exception_message_box\
+";
+
+
 // Construct the collection of Python widgets.
 PyCustomWidgets::PyCustomWidgets(QObject *parent) : QObject(parent),
         sys_path(0), sip_unwrapinstance(0), qtdesigner_custom(0)
@@ -134,6 +310,104 @@
         PyGILState_STATE gil_state = PyGILState_Ensure();
 #endif
 
+        qDebug() << "Preparing to import module";
+
+        // https://stackoverflow.com/a/42853449/228539
+        PyObject *pyModule = PyModule_New(moduleName);
+        // Set properties on the new module object
+        PyModule_AddStringConstant(pyModule, "__file__", "");
+        PyObject *localDict = PyModule_GetDict(pyModule);   // Returns a borrowed reference: no need to Py_DECREF() it once we are done
+        PyObject *builtins = PyEval_GetBuiltins();  // Returns a borrowed reference: no need to Py_DECREF() it once we are done
+        PyDict_SetItemString(localDict, "__builtins__", builtins);
+
+        qDebug() << "About to import module";
+
+        // Define code in the newly created module
+        PyObject *pyValue = PyRun_String(moduleCode, Py_file_input, localDict, localDict);
+        if (pyValue == NULL)
+        {
+            qDebug() << "An error occurred while importing the module";
+
+            char * full_backtrace = NULL;
+            
+            if (PyErr_Occurred() != NULL) {
+                qDebug() << "PyErr_Occurred() != NULL";
+                PyObject *ptype, *pvalue, *ptraceback;
+                PyObject *pystr, *module_name, *pyth_module, *pyth_func;
+                char *str;
+                char *error_description;
+
+                PyErr_Fetch(&ptype, &pvalue, &ptraceback);
+                pystr = PyObject_Str(pvalue);
+                pystr = PyUnicode_AsEncodedString(pystr, "utf-8", "error 1?");
+                str = PyBytes_AS_STRING(pystr);
+                Py_DECREF(pystr);
+                error_description = strdup(str);
+
+                /* See if we can get a full traceback */
+                module_name = PyUnicode_Decode("traceback", 9, "utf-8", "error 2?");
+                pyth_module = PyImport_Import(module_name);
+                Py_DECREF(module_name);
+
+                if (pyth_module == NULL) {
+                    qDebug() << "pyth_module == NULL";
+                    full_backtrace = NULL;
+                    return;
+                }
+
+                pyth_func = PyObject_GetAttrString(pyth_module, "format_exception");
+                if (pyth_func && PyCallable_Check(pyth_func))
+                {
+                    qDebug() << "pyth_func && PyCallable_Check(pyth_func)";
+                    PyObject *pyth_val;
+
+                    pyth_val = PyObject_CallFunctionObjArgs(pyth_func, ptype, pvalue, ptraceback, NULL);
+                    if (pyth_val == NULL)
+                    {
+                        qDebug() << "pyth_val == NULL";
+                    }
+
+                    pystr = PyObject_Str(pyth_val);
+                    if (pystr == NULL)
+                    {
+                        qDebug() << "pystr == NULL";
+                    }
+
+                    pystr = PyUnicode_AsEncodedString(pystr, "utf-8", "error 3?");
+                    if (pystr == NULL)
+                    {
+                        qDebug() << "pystr == NULL";
+                    }
+
+                    str = PyBytes_AS_STRING(pystr);
+                    if (str == NULL)
+                    {
+                        qDebug() << "str == NULL";
+                    }
+
+                    Py_DECREF(pystr);
+                    full_backtrace = strdup(str);
+                    Py_DECREF(pyth_val);
+                }
+            }
+            
+            if (full_backtrace != NULL)
+            {
+                qDebug() << "About to print backtrace";
+                qDebug() << full_backtrace;
+            }
+            else
+            {
+                qDebug() << "Backtrace was NULL";
+            }
+        }
+        else
+        {
+            Py_DECREF(pyValue);
+        }
+
+        qDebug() << "Done to importing module";
+
         bool fatal = importPlugins(dir, plugins);
 
 #if defined(WITH_THREAD)
